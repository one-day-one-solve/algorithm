# 2025년 7월 3주차 문제 풀이 회고

## 120. Triangle

2차원 dp 배열을 만들고 `dp[i][j] = i, j 번째의 누적 합`이라고 정의하여 문제를 풀이했다.

아래 점화식을 통해 문제를 풀이했다:

- 행에서 가장 첫 번째 요소: dp[i][0] += dp[i - 1][0] + triangle[i][j]
- 행에서 가장 마지막 요소: dp[i]dp[i].length - 1] += dp[i - 1]dp[i - 1].length - 1] + triangle[i][j]
- 나머지: dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]

## 64. Minimum Path Sum

2차원 dp 배열을 사용하고 점화식은 아래와 같다.

`dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

## 63. Unique Paths II

64번 문제와 거의 비슷하게 풀이를 했다. 단, 이번에는 파라미터로 주어진 obstacleGrid에 장애물이 있다는 조건이 있어 dp 배열의 요소를 채울 때, 조건을 추가했다.

obstacleGrid의 요소가 1이 아닌 경우에만 아래 점화식을 통해 dp 배열의 요소를 채워 unique한 경로를 찾아낼 수 있었다.

`dp[i][j] += dp[i - 1][j] + dp[i][j - 1];`

## 5. Longest Palindromic Substring

처음에는 dp 배열 없이 l과 r이라는 pointer를 사용해서 s의 l부터 r까지의 substring이 palindrome에 해당되는지 판단하는 로직을 생각했다. while문을 통해서 l과 r이라는 포인터를 사용해서 양쪽 포인터가 가르키는 문자가 서로 동일한지를 비교하고 중간에 다르다면 isPalindromicStr 변수를 false로 변환해 palindromic string이 아니라는 것을 판단했다. 그런데 Wrong Answer가 떴다.

2번째 풀이에서는 2차원 boolean 배열을 사용하여 풀이를 했다.

dp 배열의 정의는 아래와 같다:

`dp[i][j] = s.substring(i, j+1)이 palindromic string인지 참, 거짓을 저장하는 배열`

길이가 1일 때는 무조건 true로 길이가 2인 경우는 두 글자가 같은 경우를 true로 업데이트 했다.

길이가 3인 경우는 아래 점화식을 사용하여 palindromic string을 찾아냈다.

`dp[i][j] = s[i] === s[j] && dp[i+1][j-1]`

마지막으로 longestStr 이라는 변수를 두어서 palindromic string을 찾을 때마다 현재 longestStr 변수에 담긴 문자열의 길이를 비교하여 더 긴 경우에만 longestStr 변수를 업데이트했다.
